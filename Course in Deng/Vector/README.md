# Vector

## 1 主要接口

### 1.1 size()

返回元素的个数，未涉及到算法。复杂度*O*(1)

### 1.2 get(r)

循秩访问，返回秩为r的元素，未涉及到算法。复杂度*O*(1)

### 1.3 put(r,e)

循秩访问、替换，未涉及到算法。复杂度*O*(1)

### 1.4 insert(r,e)

循秩访问，插入，未涉及到算法。分摊复杂度*O*(n)，0,1,2,3,.....,n

### 1.5 remove(r)

### 1.6disordered()

### 1.7 sort()

涉及到算法，采用不同的算法会有不同的复杂度。

### 1.8 find()

普通无序向量的查找，必须实打实的查找，没有优化的算法。

### 1.9 search()

有序向量的查找，算法设计。二分查找，三种实现方式：三路(返回index，-1)，二路(返回index，-1)，二路(返回index，两种不小于，不大于)

### 1.10 deduplicate()

无序向量的去重函数。

### 1.11 uniquify()

有序向量的去重函数。

### 1.12 traverse(visit)

遍历向量中元素的接口。两种visit机制，传入函数指针，传入函数对象。

## 2 查找算法

算法复杂度都是*O*(logn)，由递推方程导出，T(n) = T(n/2) + *O*(1)

### 2.1 二分查找1

普通的三路查找，分为三支，小于，大于，等于，遇到等于时就可以结束，最好的情况表现最好，但是遇到最坏的情况时就比较糟糕了。在常数项上表现略差。因为不同选择的操作数有差异，经过几次比较:1,2,3

### 2.2 二分查找2

普通的二路查找，只有两支：小于，大于等于，只有二分完毕后，才能推出，不能提前退出，所以最好的情况时，变得很糟糕，但是最坏的情况下，由于减少了比较次数，变得更好的了，所以此种实现方式在整个Vector的查找上表现的更加稳定。

### 2.3 二分查找3

上面的两种二分查找返回的要么是index，要么是-1表示没有找到。若要无论查找到还是否都要返回一个index，即vector[index]=<e<vector[index]，或者vector[index]<e<=vector[index+1]。于是便有了这种实现方式。

### 2.4 二分查找4

同上。

### 2.5 Fibonacci查找

由于在普通的二分查找时，左右两分支的比较操作不均等，左少右多，那么我们是否可以认为的将之均衡一下。答案当然是可以，分给左侧更多的元素，即此时不在均衡的分，而是偏向于一边。用何实现？用Fabonacci数列实现，此时可以证明这就是最优的。

## 3 排序算法

### 3.1 起泡排序

两种实现方式，一种比另一种稍微快一点

### 3.2 归并排序

### 3.3 选择排序

### 3.4 堆排序

### 3..5快速排序

###  